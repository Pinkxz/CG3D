<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>Vidro com Reflexo + Refração + Clipping + Flyby</title>
<style>
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
}
canvas {
    width: 100%;
    height: 100%;
    display: block;
}
</style>
</head>
<body>

<canvas id="glcanvas"></canvas>

<script>
/* ================= CONTEXTO ================= */
const canvas = document.getElementById("glcanvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL não suportado");

gl.viewport(0, 0, canvas.width, canvas.height);
gl.clearColor(0.2, 0.4, 0.8, 1.0);
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

/* ================= SHADERS ================= */
const vsSource = `
attribute vec2 aPos;
attribute vec2 aUV;

uniform vec2 uCamPos;
uniform float uZoom;

varying vec2 vUV;
varying vec2 vPos;

void main() {
    vec2 pos = (aPos - uCamPos) * uZoom;
    vUV = aUV;
    vPos = pos;
    gl_Position = vec4(pos, 0.0, 1.0);
}
`;

const fsObj = `
precision mediump float;

uniform vec3 uClipPlane;
varying vec2 vPos;

void main() {
    float d = dot(uClipPlane.xy, vPos) + uClipPlane.z;
    if (d < 0.0) discard;

    gl_FragColor = vec4(0.9, 0.2, 0.2, 1.0);
}
`;

const fsGlass = `
precision mediump float;

uniform sampler2D uScene;
uniform float uAlpha;
uniform vec3 uClipPlane;
uniform float uFresnelPower;

varying vec2 vUV;
varying vec2 vPos;

void main() {
    float d = dot(uClipPlane.xy, vPos) + uClipPlane.z;
    if (d < 0.0) discard;

    // Normal fake do vidro
    vec3 normal = normalize(vec3(vUV - 0.5, 1.0));

    // ===== REFRAÇÃO =====
    float refractStrength = 0.05;
    vec2 refractUV = vUV + normal.xy * refractStrength;
    vec3 refracted = texture2D(uScene, refractUV).rgb;

    // ===== REFLEXÃO =====
    vec2 reflUV = vec2(1.0 - vUV.x, vUV.y);
    vec3 reflected = texture2D(uScene, reflUV).rgb;

    // ===== FRESNEL =====
    vec3 viewDir = vec3(0.0, 0.0, 1.0);
    float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), uFresnelPower);

    // Cor base do vidro
    vec3 glassColor = vec3(0.05, 0.1, 0.15);

    // Combinação final
    vec3 base = mix(refracted, glassColor, 0.3);
    vec3 finalColor = mix(base, reflected, fresnel);

    gl_FragColor = vec4(finalColor, uAlpha);
}
`;

function compile(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(s));
    return s;
}

function makeProgram(vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    return p;
}

const vs = compile(vsSource, gl.VERTEX_SHADER);
const progObj = makeProgram(vs, compile(fsObj, gl.FRAGMENT_SHADER));
const progGlass = makeProgram(vs, compile(fsGlass, gl.FRAGMENT_SHADER));

/* ================= GEOMETRIA ================= */
const vertices = new Float32Array([
    // esquerda
    -0.9, -0.5, 0,0,
    -0.3, -0.5, 1,0,
    -0.3,  0.5, 1,1,
    -0.9,  0.5, 0,1,

    // direita
     0.3, -0.5, 0,0,
     0.9, -0.5, 1,0,
     0.9,  0.5, 1,1,
     0.3,  0.5, 0,1,

    // vidro
    -0.3, -0.6, 0,0,
     0.3, -0.6, 1,0,
     0.3,  0.6, 1,1,
    -0.3,  0.6, 0,1
]);

const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

/* ================= FRAMEBUFFER ================= */
const fb = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

const fbTex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, fbTex);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbTex, 0);
gl.bindFramebuffer(gl.FRAMEBUFFER, null);

/* ================= CONTROLES ================= */
let alpha = 0.4;
let clip = 0.0;
let fresnelPower = 2.5;
let camX = 0.0;
let camY = 0.0;
let zoom = 1.0;

window.addEventListener("keydown", e => {
    if (e.key === "+") alpha = Math.min(1.0, alpha + 0.05);
    if (e.key === "-") alpha = Math.max(0.05, alpha - 0.05);

    if (e.key === "ArrowLeft") clip -= 0.05;
    if (e.key === "ArrowRight") clip += 0.05;

    if (e.key === "a") camX -= 0.05;
    if (e.key === "d") camX += 0.05;
    if (e.key === "w") camY += 0.05;
    if (e.key === "s") camY -= 0.05;

    if (e.key === "q") zoom *= 1.05;
    if (e.key === "e") zoom *= 0.95;
    if (e.key === "z") fresnelPower = Math.max(0.5, fresnelPower - 0.2);
    if (e.key === "x") fresnelPower += 0.2;

});

/* ================= DRAW ================= */
function drawRange(program, start) {
    gl.useProgram(program);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);

    const p = gl.getAttribLocation(program, "aPos");
    const uv = gl.getAttribLocation(program, "aUV");

    gl.enableVertexAttribArray(p);
    gl.enableVertexAttribArray(uv);

    gl.vertexAttribPointer(p, 2, gl.FLOAT, false, 16, 0);
    gl.vertexAttribPointer(uv, 2, gl.FLOAT, false, 16, 8);

    gl.uniform3f(gl.getUniformLocation(program, "uClipPlane"), 1.0, 0.0, clip);
    gl.uniform2f(gl.getUniformLocation(program, "uCamPos"), camX, camY);
    gl.uniform1f(gl.getUniformLocation(program, "uZoom"), zoom);

    gl.drawArrays(gl.TRIANGLE_FAN, start, 4);
}

function render() {
    // Framebuffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.viewport(0,0,512,512);
    gl.clear(gl.COLOR_BUFFER_BIT);
    drawRange(progObj, 0);
    drawRange(progObj, 4);

    // Cena final
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    drawRange(progObj, 0);
    drawRange(progObj, 4);

    gl.uniform1f(
        gl.getUniformLocation(progGlass, "uFresnelPower"),
        fresnelPower
    );


    gl.useProgram(progGlass);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, fbTex);
    gl.uniform1i(gl.getUniformLocation(progGlass, "uScene"), 0);
    gl.uniform1f(gl.getUniformLocation(progGlass, "uAlpha"), alpha);
    drawRange(progGlass, 8);

    requestAnimationFrame(render);
}
render();
</script>

</body>
</html>
